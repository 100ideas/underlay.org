# Namespaces and URIs

tasl schemas use _URIs_ from _namespaces_ to identify things.

We use URIs in tasl in three ways: to name classes, to name properties, and to identify datatypes. We'll talk about datatypes in the next section, and just focus on the first two here. Don't worry too much about what "classes" and "properties" are exactly - for now, we're just using them casually to mean "things" and "relationships between things".

A namespace is just a "base" URI that ends in `/` or `#`, like `http://schema.org/` or `http://example.com/hello/world#`. When we want to use terms from a namespace in a tasl schema, we have to declare that namespace in the beginning of the schema like this:

```tasl
# This is a tasl schema!
# Comments begin with `#`

namespace s http://schema.org/
namespace ex http://example.com/ns#
namespace rdf http://www.w3.org/1999/02/22-rdf-syntax-ns#
```

"Declaring a namespace" means giving it a short, local prefix - `s`, `ex`, and `rdf` in the example. When we actually use terms from the namespace, we'll always use this short prefix instead of the full base URI. For example, we'd write `s:Person` (which "expands" to `http://schema.org/Person`) or `ex:favoriteColor` (which "expands" to `http://example.com/ns#favoriteColor`), and so on. The prefixes that you give to namespaces are only scoped to each individual tasl file, and they can be whatever you want them to be, as long as they only consist of letters and numbers (and start with a lowercase letter)

## Using your own namespace

The easiest (and _safest_) way to get started writing schemas is to use your own namespace. You don't even have to actually _do_ anything to "create a namespace" - you don't have to run a server, or publish it anywhere, or tell anybody. You can just pick a URL that you own and start using it:

```tasl
namespace hello http://my-own-domain.com/a/cool/namespace#

# The full name of this class is
# http://my-own-domain.com/a/cool/namespace#world
class hello:world {
  # ...
}
```

What _is_ important is that the base URI that you pick is actually _yours_. This typically means that it's a `http://` URL under a domain name that you own. This is important because the purpose of using URIs is to treat them as globally unique - so that anyone who encounters the same URI in two different schemas can assume that they "mean" the same thing. A schemas is mostly useful for modeling the specific dataset it's developed for, but the URIs also serve as an interface to the outside world (full of other schemas) that can enable all kinds of inter-schema use cases. This won't work if people start using the same URIs in different ways, so good practice is to only use URIs that you have the authority to use. This is never enforced - it's just part of the social contract of writing schemas.

Again, there doesn't have to _be_ anything at the URL `http://my-own-domain.com/a/cool/namespace#`. None of the tools will try to look for anything there. URLs are just the most convenient and accessible way for everyone to agree on who controls what namespace in a (relatively) decentralized fashion.

Some namespace naming tips:

-   always use `http`; never use `https`
-   use a domain name that you have authority over
-   pick something that feels stable to you

## Using terms from existing namespaces

Thereâ€™s another way for people to agree on how to use a URI consistently - somebody can create a namespace, list and document a vocabulary of terms in that namespace in a human-readable format, and then everybody can just follow that.

A namespace represents a specific vocabulary of URIs that all begin with that root - in this case, the full schema.org vocabulary is listed on [this webpage](https://schema.org/docs/full.html). The terms in the vocabulary are URIs like `http://schema.org/Person`, `http://schema.org/name`, `http://schema.org/knows`, etc., and they all have human-readable definitions:

-   `http://schema.org/Person`: A person (alive, dead, undead, or fictional).
-   `http://schema.org/name`: The name of the item.
-   `http://schema.org/knows`: The most generic bi-directional social/work relation.

```tasl
namespace s http://schema.org/
namespace ex http://example.com/ns#

class s:Person {
	ex:favoriteColor -> string;
}
```

Each namespace usually has a recommended canonical prefix, but you don't necessarily have to use them.

## Schemas vs ontologies

Vocabularies like schema.org define an abstract web of things and relationships, but that web isn't really a _schema_ (regardless of what the name "schema.org" would have you believe). A schema is a set of specific shapes that describe the layout and format of data in a dataset - like listing exactly what tables are in a database, what columns they each have, and the datatypes of those columns. The thing that the vocabulary in a namespace defines is more like an _ontology_.

A simplified way of thinking about it is that a namespace defines the meaning of its terms, and a

Namespaces are not a formal concept - they're not registered anywhere, there's no standard way to list all of the terms in a vocabulary, and nobody can stop you from mis-using them. For example, the URI `http://schema.org/xcbvxf` doesn't exist in the schema.org namespace, but none of our tools will tell you that you can't use it. URIs in tasl are an informal social contract.

This all seems like a lot of complexity - all to just name things! - but

You just have to use a root URI that you have

But by using a URI in a schema, you're promising the world that you're using it in the same way that everybody else is using it.

A typical tasl schema will have _lots_ of URIs, so writing them has to be as easy as possible.

```tasl
namespace ex http://example.com/
```
